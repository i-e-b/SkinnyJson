<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SkinnyJsonCore</name>
    </assembly>
    <members>
        <member name="T:SkinnyJson.ChainStep">
            <summary>
            Represents a step in a dynamic call chain
            </summary>
        </member>
        <member name="P:SkinnyJson.ChainStep.Name">
            <summary>
            Name of property
            </summary>
        </member>
        <member name="P:SkinnyJson.ChainStep.SingleIndex">
            <summary>
            Index lookup, if any
            </summary>
        </member>
        <member name="P:SkinnyJson.ChainStep.IsIndex">
            <summary>
            True if there is an index
            </summary>
        </member>
        <member name="M:SkinnyJson.ChainStep.PropertyStep(System.String)">
            <summary>
            Make a property lookup
            </summary>
        </member>
        <member name="M:SkinnyJson.ChainStep.IndexStep(System.Int32)">
            <summary>
            Make an indexed lookup
            </summary>
        </member>
        <member name="T:SkinnyJson.ContextTextReader">
            <summary>
            Text reader that keeps a small buffer of the start and end of data that has been read.
            This is used to improve error messages
            </summary>
        </member>
        <member name="T:SkinnyJson.DynamicProxy">
            <summary>
            Generates run-time types for Interfaces
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicProxy.GetInstanceFor``1">
            <summary>
            Return an instance of the given interface
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicProxy.GetInstanceFor(System.Type)">
            <summary>
            Return an instance of the given interface
            </summary>
        </member>
        <member name="T:SkinnyJson.DynamicWrapper">
            <summary>
            Wrapper around a parser object
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.#ctor(System.Object)">
            <summary>
            Wrap a parser output object in a dynamic object
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.#ctor(System.Object,System.Collections.Generic.List{SkinnyJson.ChainStep},SkinnyJson.ChainStep)">
            <summary>
            Wrap parser output object in a dynamic object with a query path chain
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
            <summary>
            Syntax: dyn.path.elems()
            Access value at position
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
            <summary>
            Syntax: dyn.path.elems[0]()
            Try to directly invoke an instance
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>
            Syntax: dyn.parent.child.grandchild
            Add a step in the path to access
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
            <summary>
            Syntax: Check.That....[predicate]
            applies predicate to matching paths.
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
            <summary>
            Syntax: dyn.path.elems[0] = x
            Update wrapped object at path with a new array item
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>
            Syntax: dyn.path.elems = x
            Update wrapped object at path with a new value
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
            <summary>
            Handle conversions
            </summary>
        </member>
        <member name="T:SkinnyJson.DynamicWrapper.Valuate">
            <summary>
            Helper.
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.op_Explicit(SkinnyJson.DynamicWrapper)~SkinnyJson.DynamicWrapper.Valuate">
            <summary>
            Cast path to a value
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.ToObject(SkinnyJson.DynamicWrapper)">
            <summary>
            Cast to object by resolving path
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.op_Explicit(SkinnyJson.DynamicWrapper)~System.Int32">
            <summary>
            Cast path to an integer value
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.op_Explicit(SkinnyJson.DynamicWrapper)~System.String">
            <summary>
            Cast path to a string value
            </summary>
        </member>
        <member name="T:SkinnyJson.Json">
            <summary>
            SkinnyJson entry point. Use the static methods of this class to interact with JSON data
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.Freeze(System.Object,SkinnyJson.JsonParameters)">
            <summary> Turn an object into a JSON string </summary>
        </member>
        <member name="M:SkinnyJson.Json.Freeze(System.Object,System.IO.Stream,System.Text.Encoding,SkinnyJson.JsonParameters)">
            <summary> Write an object to a stream as a JSON string </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.String,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON string into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.Byte[],SkinnyJson.JsonParameters)">
            <summary> Turn a JSON byte array into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.IO.Stream,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON data stream into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.Json.WrapperType(System.Object,SkinnyJson.JsonParameters)">
            <summary> Return the type name that SkinnyJson will use for the serialising the object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost``1(System.String,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON string into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost``1(System.IO.Stream,System.Text.Encoding,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON data stream into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost``1(System.Byte[],System.Text.Encoding,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON byte array into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.String,System.Type,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON string into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.Byte[],System.Type,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON byte array into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.IO.Stream,System.Type,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON data stream into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostDynamic(System.String,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON string into an object containing properties found </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostDynamic(System.IO.Stream,SkinnyJson.JsonParameters)">
            <summary> Turn a JSON string into an object containing properties found </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostFromPath``1(System.String,System.String,SkinnyJson.JsonParameters)">
            <summary>
            Turn a sub-path of a JSON document into an enumeration of values, by specific type
            </summary>
            <remarks>This is intended to extract useful fragments from repository-style files</remarks>
            <typeparam name="T">Type of the fragments to be returned</typeparam>
            <param name="path">Dotted path through document. If the path can't be found, an empty enumeration will be returned.
            An empty path is equivalent to `Defrost&lt;T&gt;`</param>
            <param name="json">The JSON document string to read</param>
            <param name="settings">Json parsing settings</param>
        </member>
        <member name="M:SkinnyJson.Json.Clone``1(``0)">
            <summary> Create a copy of an object through serialisation </summary>
        </member>
        <member name="M:SkinnyJson.Json.Parse(System.String,SkinnyJson.JsonParameters)">
            <summary>Read a JSON object into an anonymous .Net object</summary>
        </member>
        <member name="M:SkinnyJson.Json.Edit(System.String,System.Action{System.Object},SkinnyJson.JsonParameters)">
            <summary>
            Deserialise a string, perform some edits then reform as a new string
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.Beautify(System.String)">
            <summary>
            Pretty print a JSON string. This is done without value parsing.
            <p/>
            Note that any JS comments in the input are removed in the output.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.BeautifyStream(System.IO.Stream,System.Text.Encoding,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Pretty print a JSON data stream to another stream.
            This is done without value parsing or buffering, so very large streams can be processed.
            The input and output encodings can be the same or different.
            <p/>
            Note that any JS comments in the input are removed in the output.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostInto(System.Object,System.String,SkinnyJson.JsonParameters)">
            <summary>Fill the members of an .Net object from a JSON object string</summary>
            <remarks>Alias for <see cref="M:SkinnyJson.Json.FillObject(System.Object,System.String,SkinnyJson.JsonParameters)"/></remarks>
        </member>
        <member name="M:SkinnyJson.Json.FillObject(System.Object,System.String,SkinnyJson.JsonParameters)">
            <summary>Fill the members of an .Net object from a JSON object string</summary>
        </member>
        <member name="M:SkinnyJson.Json.ToJsonStatics(System.Type,SkinnyJson.JsonParameters)">
            <summary>
            Read public static properties and fields from a type, output as JSON
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.SelectObjects``1(System.Object,System.String,SkinnyJson.WarningSet,SkinnyJson.JsonParameters)">
            <summary>
            Pick items out of a parsed object using dotted string path
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.PathWalk``1(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},System.String[],System.Int32,System.Boolean,SkinnyJson.WarningSet,SkinnyJson.JsonParameters)">
            <summary>
            Recursive helper for SelectObjects˂T˃
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ToObject(System.Object,System.Type,SkinnyJson.JsonParameters)">
            <summary>
            Create a new object by type, using input json data
            </summary>
            <param name="json">Either a stream of utf-8 data or an in-memory `string`</param>
            <param name="type">Target return type</param>
            <param name="settings">Json parsing options</param>
        </member>
        <member name="M:SkinnyJson.Json.StrengthenType(System.Type,System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},SkinnyJson.WarningSet,SkinnyJson.JsonParameters)">
            <summary>
            Try to decode a parsed json object into a new type instance
            </summary>
            <param name="type">Target output type</param>
            <param name="decodedObject">raw memory map of json</param>
            <param name="globalTypes">cache of type matches</param>
            <param name="warnings">Additional information will be added to this</param>
            <param name="settings">Json parser settings</param>
        </member>
        <member name="M:SkinnyJson.Json.ParserFromStreamOrStringOrBytes(System.Object,SkinnyJson.JsonParameters)">
            <summary>
            Pass in either a string or a stream and get back a parser instance
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GenericListType(System.Type)">
            <summary>
            Make an IList˂T˃() instance for a runtime type
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GenericSetInterfaceType(System.Type)">
            <summary>
            Make an ISet˂T˃() instance for a runtime type
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GenericHashSetType(System.Type)">
            <summary>
            Make an HashSet˂T˃() instance for a runtime type
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ParseDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Object,SkinnyJson.WarningSet,SkinnyJson.JsonParameters)">
            <summary>
            Read a weakly-typed dictionary tree into a strong type. If the keys do not match exactly,
            all matching field/properties will be filled.
            If *no* keys match the target type, this will return `null`
            <p></p>
            If the input object is null, but the input type is not,
            this will attempt to fill static members of the given type.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.MapJsonValueToObject(System.String,System.Type,System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},SkinnyJson.SafeDictionary{System.String,SkinnyJson.TypePropertyInfo},SkinnyJson.WarningSet,SkinnyJson.JsonParameters)">
            <summary>
            Map json value dictionary to the properties and fields of a target object instance.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.MakeSettableObject(System.Collections.Generic.IDictionary{System.String,System.Object},SkinnyJson.TypePropertyInfo,System.Object,SkinnyJson.WarningSet,SkinnyJson.JsonParameters)">
            <summary>
            Try to create an object instance that can be directly assigned to the property or field
            defined by 'propertyInfo'.
            The value will be the best interpretation of 'inputValue' that is available.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ConvertBytes(System.Object)">
            <summary>
            Our default is Base64, but we will fall back on hex if it's input
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.HexToByteArray(System.String)">
            <summary>
            Convert a hex string to a byte array.
            <p/>
            Use <c>Convert.FromHexString</c> where available
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.WriteValueToTypeInstance(System.String,System.Type,System.Object,SkinnyJson.TypePropertyInfo,System.Object)">
            <summary>
            Inject a value into an object's property.
            If object is null, we will attempt to write to a static member.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GetProperties(System.Type,System.String,SkinnyJson.JsonParameters)">
            <summary>
            Read the properties and public fields of a type.
            In special cases, this will also read private fields
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.NormaliseCase(System.String)">
            <summary>
            Convert a string to lower case, removing a set of joining and non-printing characters
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ChangeType(System.Object,System.Type)">
            <summary>
            Convert between runtime types
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.TryGetDouble(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,SkinnyJson.JsonParameters)">
            <summary>
            Try to get a keyed value as a double, or return zero. 
            </summary>
        </member>
        <member name="T:SkinnyJson.JsonParameters">
            <summary>
            Parameters for serialising and deserialising.
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonParameters.StandardDateFormatsInPreferenceOrder">
            <summary>
            Date formats we expect from JSON strings
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonParameters.Default">
            <summary>
            Default SkinnyJson parameters.
            <p>Uses large number support, Base64 Guids, anonymous types, case insensitive matching, and strict matching.</p>
            <p>Excludes source type information and global types</p>
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonParameters.Compatible">
            <summary>
            SkinnyJson parameters, with some less-supported features turned off.
            <p>Uses anonymous types, and strict matching.</p>
            <p>Excludes large number support, case insensitive matching, Base64 Guids, source type information and global types</p>
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonParameters.TypeConstrained">
            <summary>
            SkinnyJson parameters for reading and writing strongly-typed messages.
            This is not compatible with most other JSON libraries.
            <p>Uses source type information and global types</p>
            <p>Excludes anonymous types, case insensitivity</p>
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.StreamEncoding">
            <summary>
            String encoding to use for streams, when no specific encoding is provided.
            Initial value is UTF8.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.DateFormats">
            <summary>
            String-to-Date and Date-to-String formats, in descending preference order.
            Highest preference will be used for serialisation.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.UseWideNumbers">
            <summary>
            If set to true, numeric values will be parsed as high-precision types.
            Otherwise, numeric values are parsed as double-precision floats.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.UseOptimizedDatasetSchema">
            <summary>
            Use a special format for Sql Datasets. Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.UseFastGuid">
            <summary>
            Use Base64 encoding for Guids. If false, uses Hex.
            Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.SerializeNullValues">
            <summary>
            Insert null values into JSON output. Otherwise remove field.
            Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.UseUtcDateTime">
            <summary>
            Force date times to UTC. Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.ShowReadOnlyProperties">
            <summary>
            Serialise properties that can't be written on deserialise. Default false
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.UsingGlobalTypes">
            <summary>
            Declare types once at the start of a document. Otherwise declare in each object.
            Default true, but overridden by `EnableAnonymousTypes`
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.IgnoreCaseOnDeserialize">
            <summary>
            <p>Default false.</p>
            Allow case insensitive matching on deserialise. Also ignores underscores, dashes, and spaces in object keys.
            </summary>
            <remarks>
            If case insensitive matching is enabled, these are all considered equal keys:
            <ul>
            <li>CASE_INSENSITIVE</li>
            <li>CASE-INSENSITIVE</li>
            <li>CASEINSENSITIVE</li>
            <li>case_insensitive</li>
            <li>case-insensitive</li>
            <li>Case Insensitive</li>
            <li>case insensitive</li>
            <li>CaseInsensitive</li>
            <li>caseInsensitive</li>
            <li>caseinsensitive</li>
            </ul>
            </remarks>
        </member>
        <member name="P:SkinnyJson.JsonParameters.StrictMatching">
            <summary>
            Default true.
            <p/>
            When true, and an object is deserialised which has values in the JSON side, but none of them match
            the class definition, then deserialisation fails.
            <p/>
            When false, an object with mismatching data is allowed to pass, and may result in empty objects
            in the class model returned.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.EnableAnonymousTypes">
            <summary>
            Default true. If false, source type information will be included in serialised output.
            <p/>
            Overrides `UseExtensions` and `UsingGlobalTypes` 
            Directly serialising an anonymous type will use these settings for that call, without needing a global setting.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonParameters.UseTypeExtensions">
            <summary>
            Add type and schema information to output JSON, using $type, $types, $schema and $map properties.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonParameters.WithAnonymousTypes">
            <summary>
            Copy of these settings, but with type extensions disabled and anonymous types enabled
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonParameters.WithEncoding(System.Text.Encoding)">
            <summary>
            Change the byte-to-string encoding type
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonParameters.WithDateFormats(System.String[])">
            <summary>
            Set the acceptable date formats, in descending preference order.
            Highest preference will be used for serialisation.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonParameters.WithCaseSensitivity">
            <summary>
            Add case sensitive matching to these parameters
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonParameters.ParameterKey">
            <summary>
            Unique key for this parameter set.
            Used to key various caches.
            </summary>
        </member>
        <member name="T:SkinnyJson.JsonParser">
            <summary>
            This class encodes and decodes JSON strings.
            Spec. details, see http://www.json.org/
            
            JSON uses Arrays and Objects. These correspond here to the data types ArrayList and Hashtable.
            All numbers are parsed to doubles.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonParser.#ctor(System.String,SkinnyJson.JsonParameters)">
            <summary>
            Create a parser for an JSON string loaded in memory
            </summary>
            <param name="json">The input JSON string</param>
            <param name="settings">Json interpretation settings</param>
        </member>
        <member name="M:SkinnyJson.JsonParser.#ctor(System.IO.Stream,SkinnyJson.JsonParameters)">
            <summary>
            Create a parser for an JSON string accessible as a stream
            </summary>
            <param name="json">The input JSON stream</param>
            <param name="settings">Json interpretation settings</param>
        </member>
        <member name="M:SkinnyJson.JsonParser.#ctor(System.Byte[],SkinnyJson.JsonParameters)">
            <summary>
            Create a parser for an JSON byte array loaded in memory
            </summary>
            <param name="json">The input JSON byte array</param>
            <param name="settings">Json interpretation settings</param>
        </member>
        <member name="M:SkinnyJson.JsonParser.Decode">
            <summary>
            Decode the provided JSON into an object representation
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.ConvertToJson(System.Object,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Serialise a .Net object to a writable stream.
            Ignores the 'globalTypes' setting, will always either write types inline or elide them.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.ConvertStaticsToJson(System.Type)">
            <summary>
            Output the static fields and properties of a .Net type
            as a JSON string.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.ConvertToJson(System.Object)">
            <summary>
            Output a .Net object as a JSON string.
            Supports global types
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.WriteValue(System.Object)">
            <summary>
            This is the root of the serialiser.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.WriteStringFast(System.String)">
            <summary>
            Directly output strings we know won't need escape sequences
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.WriteString(System.String)">
            <summary>
            Write a string to the output, converting characters to escape sequences where needed.
            </summary>
        </member>
        <member name="T:SkinnyJson.SafeDictionary`2">
            <summary>
            Dictionary with thread locks
            </summary>
        </member>
        <member name="M:SkinnyJson.SafeDictionary`2.TryAdd(`0,`1)">
            <summary>
            Add a key/value pair only if the key is not already present
            </summary>
        </member>
        <member name="F:SkinnyJson.TypeManager._caches">
            <summary> Per-settings caches of type info</summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.Cache(SkinnyJson.JsonParameters)">
            <summary>
            Get caches for setting spec. Creates a new set if needed.
            </summary>
        </member>
        <member name="T:SkinnyJson.TypeManager.CreateObject">
            <summary>
            Delegate for creating a new type instance
            </summary>
        </member>
        <member name="T:SkinnyJson.TypeManager.GenericGetter">
            <summary>
            Function definition to get the value of a field or properly on an object
            </summary>
            <param name="obj))">object instance to provide the value</param>
        </member>
        <member name="T:SkinnyJson.TypeManager.GenericSetter">
            <summary>
            Function definition to set the value of a field or properly on an object
            </summary>
            <param name="target">object instance to accept the value</param>
            <param name="value">value of property to set</param>
            <param name="key">optional key for dictionaries</param>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetTypeAssemblyName(System.Type,SkinnyJson.JsonParameters)">
            <summary>
            Get a shortened string name for a type's containing assembly
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.ShortenName(System.String)">
            <summary>
            Shorten an assembly qualified name
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetTypeFromCache(System.String,SkinnyJson.JsonParameters)">
            <summary>
            Try to get or build a type for a given type-name
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.FastCreateInstance(System.Type,SkinnyJson.JsonParameters)">
            <summary>
            Try to make a new instance of a type.
            Will drop down to 'SlowCreateInstance' in special cases
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetGetters(System.Type,SkinnyJson.JsonParameters)">
            <summary>
            Return a list of property/field access proxies for a type.
            This is cached after first access for each type.
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.MakeFieldGetterWithPreferredName(System.Reflection.FieldInfo,SkinnyJson.TypeManager.GenericGetter)">
            <summary>
            Build a 'getter', used for serialisation.
            This will use the first name from any name-overriding attribute,
            or the name of the member directly if not overridden.
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.MakePropertyGetterWithPreferredName(System.Reflection.PropertyInfo,SkinnyJson.TypeManager.GenericGetter)">
            <summary>
            Build a 'getter', used for serialisation.
            This will use the first name from any name-overriding attribute,
            or the name of the member directly if not overridden.
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateMyProp(System.Type,System.String)">
            <summary>
            Read reflection data for a type
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.IsNullableWrapper(System.Type)">
            <summary>
            <c>true</c> if the type is <c>Nullable&lt;T&gt;</c>
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetChangeType(System.Type)">
            <summary>
            Get the true target type, excluding known wrappers
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateSetMethod(System.Reflection.PropertyInfo)">
            <summary>
            Try to create a value-setting proxy for an object property
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateGetField(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Create a value-reading proxy for an object field
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateSetField(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Create a value-setting proxy for an object field
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateGetMethod(System.Reflection.PropertyInfo)">
            <summary>
            Try to create a value-reading proxy for an object property
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetAlternativeNames(System.Reflection.MemberInfo)">
            <summary>
            Returns alternative names for a field, based on various other libraries' code attributes
            </summary>
        </member>
        <member name="T:SkinnyJson.TypePropertyInfo">
            <summary>
            Record of reflected type info for fields and properties on objects
            </summary>
        </member>
        <member name="T:SkinnyJson.WideNumber">
            <summary>
            Holds a representation of various numeric types.
            Handles casting to target types
            </summary>
        </member>
        <member name="M:SkinnyJson.WideNumber.TryParse(System.String,SkinnyJson.WideNumber@)">
            <summary>
            Try to parse a string as a range of wide number types.
            Returns true if at least one type parsed successfully.
            </summary>
        </member>
        <member name="M:SkinnyJson.WideNumber.CastTo(System.Type,System.Boolean@)">
            <summary>
            Try to cast this WideNumber type to a primitive value.
            Returns null if the cast is not supported.
            </summary>
            <param name="type">Target type</param>
            <param name="precisionLoss">Set to true if the cast is from a floating point to a fixed point or integer value; or from a fixed point to integer value</param>
            <returns></returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
    </members>
</doc>
