<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SkinnyJsonCore</name>
    </assembly>
    <members>
        <member name="T:SkinnyJson.SJson">
            <summary>
            SkinnyJson entry point. Use the static methods of this class to interact with JSON data
            </summary>
            <remarks>
            This is an alias for <see cref="T:SkinnyJson.Json"/> to work around naming conflicts
            </remarks>
        </member>
        <member name="M:SkinnyJson.SJson.Freeze(System.Object,SkinnyJson.JsonSettings)">
            <summary> Turn an object into a JSON string </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Freeze(System.Object,System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Write an object to a stream as a JSON string </summary>
        </member>
        <member name="M:SkinnyJson.SJson.FreezeToBytes(System.Object,SkinnyJson.JsonSettings)">
            <summary> Turn an object into a JSON string encoded to a byte array </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost(System.String,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost(System.Byte[],SkinnyJson.JsonSettings)">
            <summary> Turn a JSON byte array into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost(System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON data stream into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.SJson.WrapperType(System.Object,SkinnyJson.JsonSettings)">
            <summary> Return the type name that SkinnyJson will use for the serialising the object </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost``1(System.String,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost``1(System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON data stream into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost``1(System.Byte[],SkinnyJson.JsonSettings)">
            <summary> Turn a JSON byte array into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost(System.String,System.Type,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost(System.Byte[],System.Type,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON byte array into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Defrost(System.IO.Stream,System.Type,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON data stream into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.SJson.DefrostDynamic(System.String,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into an object containing properties found </summary>
        </member>
        <member name="M:SkinnyJson.SJson.DefrostDynamic(System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into an object containing properties found </summary>
        </member>
        <member name="M:SkinnyJson.SJson.DefrostFromPath``1(System.String,System.String,SkinnyJson.JsonSettings)">
            <summary>
            Turn a sub-path of a JSON document into an enumeration of values, by specific type
            </summary>
            <remarks>This is intended to extract useful fragments from repository-style files</remarks>
            <typeparam name="T">Type of the fragments to be returned</typeparam>
            <param name="path">Dotted path through document. If the path can't be found, an empty enumeration will be returned.
            An empty path is equivalent to `Defrost&lt;T&gt;`</param>
            <param name="json">The JSON document string to read</param>
            <param name="settings">Json parsing settings</param>
        </member>
        <member name="M:SkinnyJson.SJson.Clone``1(``0)">
            <summary> Create a copy of an object through serialisation </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Parse(System.String,SkinnyJson.JsonSettings)">
            <summary>Read a JSON object into an anonymous .Net object</summary>
        </member>
        <member name="M:SkinnyJson.SJson.Edit(System.String,System.Action{System.Object},SkinnyJson.JsonSettings)">
            <summary>
            Deserialise a string, perform some edits then reform as a new string
            </summary>
        </member>
        <member name="M:SkinnyJson.SJson.Beautify(System.String)">
            <summary>
            Pretty print a JSON string. This is done without value parsing.
            <p/>
            Note that any JS comments in the input are removed in the output.
            </summary>
        </member>
        <member name="M:SkinnyJson.SJson.BeautifyStream(System.IO.Stream,System.Text.Encoding,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Pretty print a JSON data stream to another stream.
            This is done without value parsing or buffering, so very large streams can be processed.
            The input and output encodings can be the same or different.
            <p/>
            Note that any JS comments in the input are removed in the output.
            </summary>
        </member>
        <member name="M:SkinnyJson.SJson.DefrostInto(System.Object,System.String,SkinnyJson.JsonSettings)">
            <summary>Fill the members of an .Net object from a JSON object string</summary>
            <remarks>Alias for <see cref="M:SkinnyJson.SJson.FillObject(System.Object,System.String,SkinnyJson.JsonSettings)"/></remarks>
        </member>
        <member name="M:SkinnyJson.SJson.FillObject(System.Object,System.String,SkinnyJson.JsonSettings)">
            <summary>Fill the members of an .Net object from a JSON object string</summary>
        </member>
        <member name="M:SkinnyJson.SJson.HexToByteArray(System.String)">
            <summary>
            Convert a hex string to a byte array.
            <p/>
            Use <c>Convert.FromHexString</c> where available
            </summary>
        </member>
        <member name="T:SkinnyJson.ChainStep">
            <summary>
            Represents a step in a dynamic call chain
            </summary>
        </member>
        <member name="P:SkinnyJson.ChainStep.Name">
            <summary>
            Name of property
            </summary>
        </member>
        <member name="P:SkinnyJson.ChainStep.SingleIndex">
            <summary>
            Index lookup, if any
            </summary>
        </member>
        <member name="P:SkinnyJson.ChainStep.IsIndex">
            <summary>
            True if there is an index
            </summary>
        </member>
        <member name="M:SkinnyJson.ChainStep.PropertyStep(System.String)">
            <summary>
            Make a property lookup
            </summary>
        </member>
        <member name="M:SkinnyJson.ChainStep.IndexStep(System.Int32)">
            <summary>
            Make an indexed lookup
            </summary>
        </member>
        <member name="T:SkinnyJson.ContextTextReader">
            <summary>
            Text reader that keeps a small buffer of the start and end of data that has been read.
            This is used to improve error messages
            </summary>
        </member>
        <member name="T:SkinnyJson.ICustomJsonConverter`1">
            <summary>
            Base class for custom JSON converters
            </summary>
        </member>
        <member name="M:SkinnyJson.ICustomJsonConverter`1.FromJson(System.Object)">
            <summary>
            Convert an object extracted from the source JSON into the target type
            </summary>
        </member>
        <member name="M:SkinnyJson.ICustomJsonConverter`1.ToJson(`0)">
            <summary>
            Convert a value to a JSON object.
            This should return an object value that will be converted to JSON normally
            </summary>
        </member>
        <member name="T:SkinnyJson.CustomJsonConverterAttribute">
            <summary>
            Instructs the serializer to use the specified converter when serialising the decorated property
            </summary>
        </member>
        <member name="P:SkinnyJson.CustomJsonConverterAttribute.ConverterType">
            <summary>
            Gets the converter to use
            </summary>
        </member>
        <member name="P:SkinnyJson.CustomJsonConverterAttribute.ConverterParameters">
            <summary>
            The parameter list to use when constructing the JsonConverter described by <see cref="P:SkinnyJson.CustomJsonConverterAttribute.ConverterType"/>.
            If <c>null</c>, the default constructor is used.
            </summary>
        </member>
        <member name="M:SkinnyJson.CustomJsonConverterAttribute.#ctor(System.Type)">
            <summary>
            <p>Initializes a new instance of the <see cref="T:SkinnyJson.CustomJsonConverterAttribute"/> class.</p>
            The <paramref name="converterType"/> should be one of:
            <ul>
            <li><c>System.Text.Json.Serialization.JsonConverter&lt;T&gt;</c></li>
            <li><c>System.Text.Json.Serialization.JsonConverter</c></li>
            <li><c>SkinnyJson.CustomJsonConverter&lt;T&gt;</c></li>
            </ul>
            </summary>
            <param name="converterType">Type of the JsonConverter.</param>
        </member>
        <member name="M:SkinnyJson.CustomJsonConverterAttribute.#ctor(System.Type,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:SkinnyJson.CustomJsonConverterAttribute"/> class.
            </summary>
            <param name="converterType">Type of the converter.</param>
            <param name="converterParameters">Parameter list to use when constructing the converter. Can be <c>null</c>.</param>
        </member>
        <member name="T:SkinnyJson.JsonNameAttribute">
            <summary>
            Set a custom name for given property or field.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonNameAttribute.#ctor(System.String)">
            <summary>
            Create a new custom name attribute
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonNameAttribute.Name">
            <summary>
            Custom name
            </summary>
        </member>
        <member name="T:SkinnyJson.DynamicProxy">
            <summary>
            Generates run-time types for Interfaces
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicProxy.GetInstanceFor``1">
            <summary>
            Return an instance of the given interface
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicProxy.GetInstanceFor(System.Type)">
            <summary>
            Return an instance of the given interface
            </summary>
        </member>
        <member name="T:SkinnyJson.DynamicWrapper">
            <summary>
            Wrapper around a parser object
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.#ctor(System.Object)">
            <summary>
            Wrap a parser output object in a dynamic object
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.#ctor(System.Object,System.Collections.Generic.List{SkinnyJson.ChainStep},SkinnyJson.ChainStep)">
            <summary>
            Wrap parser output object in a dynamic object with a query path chain
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
            <summary>
            Syntax: dyn.path.elems()
            Access value at position
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
            <summary>
            Syntax: dyn.path.elems[0]()
            Try to directly invoke an instance
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>
            Syntax: dyn.parent.child.grandchild
            Add a step in the path to access
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
            <summary>
            Syntax: Check.That....[predicate]
            applies predicate to matching paths.
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
            <summary>
            Syntax: dyn.path.elems[0] = x
            Update wrapped object at path with a new array item
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>
            Syntax: dyn.path.elems = x
            Update wrapped object at path with a new value
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
            <summary>
            Handle conversions
            </summary>
        </member>
        <member name="T:SkinnyJson.DynamicWrapper.Valuate">
            <summary>
            Helper.
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.op_Explicit(SkinnyJson.DynamicWrapper)~SkinnyJson.DynamicWrapper.Valuate">
            <summary>
            Cast path to a value
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.ToObject(SkinnyJson.DynamicWrapper)">
            <summary>
            Cast to object by resolving path
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.op_Explicit(SkinnyJson.DynamicWrapper)~System.Int32">
            <summary>
            Cast path to an integer value
            </summary>
        </member>
        <member name="M:SkinnyJson.DynamicWrapper.op_Explicit(SkinnyJson.DynamicWrapper)~System.String">
            <summary>
            Cast path to a string value
            </summary>
        </member>
        <member name="F:SkinnyJson.Getters.Name">
            <summary>
            Preferred name from type of custom attributes
            </summary>
        </member>
        <member name="F:SkinnyJson.Getters.Getter">
            <summary>
            Method to extract serialisable value
            </summary>
        </member>
        <member name="F:SkinnyJson.Getters.PropertyType">
            <summary>
            Type of the field or property
            </summary>
        </member>
        <member name="F:SkinnyJson.Getters.FieldInfo">
            <summary>
            Field info from reflection, if this is a field (not a property)
            </summary>
        </member>
        <member name="F:SkinnyJson.Getters.OriginalName">
            <summary>
            The original name from type
            </summary>
        </member>
        <member name="T:SkinnyJson.Json">
            <summary>
            SkinnyJson entry point. Use the static methods of this class to interact with JSON data
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.Freeze(System.Object,SkinnyJson.JsonSettings)">
            <summary> Turn an object into a JSON string </summary>
        </member>
        <member name="M:SkinnyJson.Json.FreezeToBytes(System.Object,SkinnyJson.JsonSettings)">
            <summary> Turn an object into a JSON string encoded to a byte array </summary>
        </member>
        <member name="M:SkinnyJson.Json.Freeze(System.Object,System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Write an object to a stream as a JSON string </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.String,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.Byte[],SkinnyJson.JsonSettings)">
            <summary> Turn a JSON byte array into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON data stream into a detected object </summary>
        </member>
        <member name="M:SkinnyJson.Json.WrapperType(System.Object,SkinnyJson.JsonSettings)">
            <summary> Return the type name that SkinnyJson will use for the serialising the object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost``1(System.String,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost``1(System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON data stream into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost``1(System.Byte[],SkinnyJson.JsonSettings)">
            <summary> Turn a JSON byte array into a specific object </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.String,System.Type,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.Byte[],System.Type,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON byte array into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.Json.Defrost(System.IO.Stream,System.Type,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON data stream into a runtime type </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostDynamic(System.String,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into an object containing properties found </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostDynamic(System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary> Turn a JSON string into an object containing properties found </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostFromPath``1(System.String,System.String,SkinnyJson.JsonSettings)">
            <summary>
            Turn a sub-path of a JSON document into an enumeration of values, by specific type
            </summary>
            <remarks>This is intended to extract useful fragments from repository-style files</remarks>
            <typeparam name="T">Type of the fragments to be returned</typeparam>
            <param name="path">Dotted path through document. If the path can't be found, an empty enumeration will be returned.
            An empty path is equivalent to `Defrost&lt;T&gt;`</param>
            <param name="json">The JSON document string to read</param>
            <param name="settings">Json parsing settings</param>
        </member>
        <member name="M:SkinnyJson.Json.Clone``1(``0)">
            <summary> Create a copy of an object through serialisation </summary>
        </member>
        <member name="M:SkinnyJson.Json.Parse(System.String,SkinnyJson.JsonSettings)">
            <summary>Read a JSON object into an anonymous .Net object</summary>
        </member>
        <member name="M:SkinnyJson.Json.Edit(System.String,System.Action{System.Object},SkinnyJson.JsonSettings)">
            <summary>
            Deserialise a string, perform some edits then reform as a new string
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.Beautify(System.String)">
            <summary>
            Pretty print a JSON string. This is done without value parsing.
            <p/>
            Note that any JS comments in the input are removed in the output.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.BeautifyStream(System.IO.Stream,System.Text.Encoding,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Pretty print a JSON data stream to another stream.
            This is done without value parsing or buffering, so very large streams can be processed.
            The input and output encodings can be the same or different.
            <p/>
            Note that any JS comments in the input are removed in the output.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.DefrostInto(System.Object,System.String,SkinnyJson.JsonSettings)">
            <summary>Fill the members of an .Net object from a JSON object string</summary>
            <remarks>Alias for <see cref="M:SkinnyJson.Json.FillObject(System.Object,System.String,SkinnyJson.JsonSettings)"/></remarks>
        </member>
        <member name="M:SkinnyJson.Json.FillObject(System.Object,System.String,SkinnyJson.JsonSettings)">
            <summary>Fill the members of an .Net object from a JSON object string</summary>
        </member>
        <member name="M:SkinnyJson.Json.HexToByteArray(System.String)">
            <summary>
            Convert a hex string to a byte array.
            <p/>
            Use <c>Convert.FromHexString</c> where available
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ToJsonStatics(System.Type,SkinnyJson.JsonSettings)">
            <summary>
            Read public static properties and fields from a type, output as JSON
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.SelectObjects``1(System.Object,System.String,SkinnyJson.WarningSet,SkinnyJson.JsonSettings)">
            <summary>
            Pick items out of a parsed object using dotted string path
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.PathWalk``1(System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},System.String[],System.Int32,System.Boolean,SkinnyJson.WarningSet,SkinnyJson.JsonSettings)">
            <summary>
            Recursive helper for SelectObjects˂T˃
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ToObject(System.Object,System.Type,SkinnyJson.JsonSettings)">
            <summary>
            Create a new object by type, using input json data
            </summary>
            <param name="json">Either a stream of utf-8 data or an in-memory `string`</param>
            <param name="type">Target return type</param>
            <param name="settings">Json parsing options</param>
        </member>
        <member name="M:SkinnyJson.Json.StrengthenType(System.Type,System.Object,System.Collections.Generic.Dictionary{System.String,System.Object},SkinnyJson.WarningSet,SkinnyJson.JsonSettings)">
            <summary>
            Try to decode a parsed json object into a new type instance
            </summary>
            <param name="type">Target output type</param>
            <param name="decodedObject">raw memory map of json</param>
            <param name="globalTypes">cache of type matches</param>
            <param name="warnings">Additional information will be added to this</param>
            <param name="settings">Json parser settings</param>
        </member>
        <member name="M:SkinnyJson.Json.ParserFromStreamOrStringOrBytes(System.Object,SkinnyJson.JsonSettings)">
            <summary>
            Pass in either a string or a stream and get back a parser instance
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GenericListType(System.Type)">
            <summary>
            Make an IList˂T˃() instance for a runtime type
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GenericSetInterfaceType(System.Type)">
            <summary>
            Make an ISet˂T˃() instance for a runtime type
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GenericHashSetType(System.Type)">
            <summary>
            Make an HashSet˂T˃() instance for a runtime type
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ParseDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Object,SkinnyJson.WarningSet,SkinnyJson.JsonSettings)">
            <summary>
            Read a weakly-typed dictionary tree into a strong type. If the keys do not match exactly,
            all matching field/properties will be filled.
            If *no* keys match the target type, this will return `null`
            <p></p>
            If the input object is null, but the input type is not,
            this will attempt to fill static members of the given type.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.MapJsonValueToObject(System.String,System.Type,System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},SkinnyJson.SafeDictionary{System.String,SkinnyJson.TypePropertyInfo},SkinnyJson.WarningSet,SkinnyJson.JsonSettings)">
            <summary>
            Map json value dictionary to the properties and fields of a target object instance.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.GetSettableObjectWithCustomSerialiser(System.Type,SkinnyJson.TypePropertyInfo,System.Object,SkinnyJson.WarningSet)">
            <summary>
            Try to use a custom serialiser declared in a custom attribute
            </summary>
            <seealso cref="M:SkinnyJson.JsonSerializer.GetJsonStringWithCustomSerialiser(SkinnyJson.TypePropertyInfo,System.Object)"/>
        </member>
        <member name="M:SkinnyJson.Json.GetUtf8JsonReaderForValue(SkinnyJson.TypePropertyInfo,System.Object,System.Type)">
            <summary>
            Try to find (by reflection) and generate a <c>Utf8JsonReader</c> to feed to System.Text.Json methods
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.MakeSettableObject(System.Collections.Generic.IDictionary{System.String,System.Object},SkinnyJson.TypePropertyInfo,System.Object,SkinnyJson.WarningSet,SkinnyJson.JsonSettings)">
            <summary>
            Try to create an object instance that can be directly assigned to the property or field
            defined by 'propertyInfo'.
            The value will be the best interpretation of 'inputValue' that is available.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ConvertBytes(System.Object)">
            <summary>
            Our default is Base64, but we will fall back on hex if it's input
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.WriteValueToTypeInstance(System.String,System.Type,System.Object,SkinnyJson.TypePropertyInfo,System.Object)">
            <summary>
            Inject a value into an object's property.
            If object is null, we will attempt to write to a static member.
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.ChangeType(System.Object,System.Type)">
            <summary>
            Convert between runtime types
            </summary>
        </member>
        <member name="M:SkinnyJson.Json.TryGetDouble(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,SkinnyJson.JsonSettings)">
            <summary>
            Try to get a keyed value as a double, or return zero.
            </summary>
        </member>
        <member name="T:SkinnyJson.JsonParser">
            <summary>
            This class encodes and decodes JSON strings.
            Spec. details, see http://www.json.org/
            
            JSON uses Arrays and Objects. These correspond here to the data types ArrayList and Hashtable.
            All numbers are parsed to doubles.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonParser.#ctor(System.String,SkinnyJson.JsonSettings)">
            <summary>
            Create a parser for an JSON string loaded in memory
            </summary>
            <param name="json">The input JSON string</param>
            <param name="settings">Json interpretation settings</param>
        </member>
        <member name="M:SkinnyJson.JsonParser.#ctor(System.IO.Stream,SkinnyJson.JsonSettings)">
            <summary>
            Create a parser for an JSON string accessible as a stream
            </summary>
            <param name="json">The input JSON stream</param>
            <param name="settings">Json interpretation settings</param>
        </member>
        <member name="M:SkinnyJson.JsonParser.#ctor(System.Byte[],SkinnyJson.JsonSettings)">
            <summary>
            Create a parser for an JSON byte array loaded in memory
            </summary>
            <param name="json">The input JSON byte array</param>
            <param name="settings">Json interpretation settings</param>
        </member>
        <member name="M:SkinnyJson.JsonParser.Decode">
            <summary>
            Decode the provided JSON into an object representation
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.ConvertToJson(System.Object,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Serialise a .Net object to a writable stream.
            Ignores the 'globalTypes' setting, will always either write types inline or elide them.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.ConvertStaticsToJson(System.Type)">
            <summary>
            Output the static fields and properties of a .Net type
            as a JSON string.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.ConvertToJson(System.Object)">
            <summary>
            Output a .Net object as a JSON string.
            Supports global types
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.WriteValue(System.Object)">
            <summary>
            This is the root of the serialiser.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.GetJsonStringWithCustomSerialiser(SkinnyJson.TypePropertyInfo,System.Object)">
            <summary>
            Try to use a custom serialiser declared in a custom attribute
            </summary>
            <seealso cref="M:SkinnyJson.Json.GetSettableObjectWithCustomSerialiser(System.Type,SkinnyJson.TypePropertyInfo,System.Object,SkinnyJson.WarningSet)"/>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.GetUtf8JsonWriterForValue(SkinnyJson.TypePropertyInfo,System.IO.Stream,System.Type)">
            <summary>
            Try to find (by reflection) and generate a <c>Utf8JsonWriter</c> to feed to System.Text.Json methods
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.WriteStringFast(System.String)">
            <summary>
            Directly output strings we know won't need escape sequences.
            Otherwise use <see cref="M:SkinnyJson.JsonSerializer.WriteString(System.String)"/>
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSerializer.WriteString(System.String)">
            <summary>
            Write a string to the output, converting characters to escape sequences where needed.
            </summary>
        </member>
        <member name="T:SkinnyJson.JsonSettings">
            <summary>
            Settings for serialising and deserialising.
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonSettings.StandardDateFormatsInPreferenceOrder">
            <summary>
            Date formats we expect from JSON strings
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonSettings.Default">
            <summary>
            Default SkinnyJson parameters.
            <p>Uses large number support, Base64 Guids, anonymous types, case insensitive matching, and strict matching.</p>
            <p>Excludes source type information and global types</p>
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonSettings.Compatible">
            <summary>
            SkinnyJson parameters, with some less-supported features turned off.
            <p>Uses anonymous types, and strict matching.</p>
            <p>Excludes large number support, case insensitive matching, Base64 Guids, source type information and global types</p>
            </summary>
        </member>
        <member name="F:SkinnyJson.JsonSettings.TypeConstrained">
            <summary>
            SkinnyJson parameters for reading and writing strongly-typed messages.
            This is not compatible with most other JSON libraries.
            <p>Uses source type information and global types</p>
            <p>Excludes anonymous types, case insensitivity</p>
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.StreamEncoding">
            <summary>
            String encoding to use for streams, when no specific encoding is provided.
            Initial value is UTF8.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.DateFormats">
            <summary>
            String-to-Date and Date-to-String formats, in descending preference order.
            Highest preference will be used for serialisation.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.UseWideNumbers">
            <summary>
            If set to true, numeric values will be parsed as high-precision types.
            Otherwise, numeric values are parsed as double-precision floats.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.UseOptimizedDatasetSchema">
            <summary>
            Use a special format for Sql Datasets. Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.UseFastGuid">
            <summary>
            Use Base64 encoding for Guids. If false, uses Hex.
            Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.SerializeNullValues">
            <summary>
            Insert null values into JSON output. Otherwise remove field.
            Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.UseUtcDateTime">
            <summary>
            Force date times to UTC. Default true
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.ShowReadOnlyProperties">
            <summary>
            Serialise properties that can't be written on deserialise. Default false
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.UsingGlobalTypes">
            <summary>
            Declare types once at the start of a document. Otherwise declare in each object.
            Default true, but overridden by `EnableAnonymousTypes`
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.IgnoreCaseOnDeserialize">
            <summary>
            <p>Default false.</p>
            Allow case insensitive matching on deserialise. Also ignores underscores, dashes, and spaces in object keys.
            </summary>
            <remarks>
            If case insensitive matching is enabled, these are all considered equal keys:
            <ul>
            <li>CASE_INSENSITIVE</li>
            <li>CASE-INSENSITIVE</li>
            <li>CASEINSENSITIVE</li>
            <li>case_insensitive</li>
            <li>case-insensitive</li>
            <li>Case Insensitive</li>
            <li>case insensitive</li>
            <li>CaseInsensitive</li>
            <li>caseInsensitive</li>
            <li>caseinsensitive</li>
            </ul>
            </remarks>
        </member>
        <member name="P:SkinnyJson.JsonSettings.StrictMatching">
            <summary>
            Default true.
            <p/>
            When true, and an object is deserialised which has values in the JSON side, but none of them match
            the class definition, then deserialisation fails.
            <p/>
            When false, an object with mismatching data is allowed to pass, and may result in empty objects
            in the class model returned.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.EnableAnonymousTypes">
            <summary>
            Default true. If false, source type information will be included in serialised output.
            <p/>
            Overrides `UseExtensions` and `UsingGlobalTypes` 
            Directly serialising an anonymous type will use these settings for that call, without needing a global setting.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.SearchForBackingFields">
            <summary>
            Default true. When set, the deserialiser will try to find and write to backing fields for get-only properties.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.UseTypeExtensions">
            <summary>
            Add type and schema information to output JSON, using $type, $types, $schema and $map properties.
            </summary>
        </member>
        <member name="P:SkinnyJson.JsonSettings.MaxDepth">
            <summary>
            Maximum recursion depth during serialisation
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSettings.WithAnonymousTypes">
            <summary>
            Copy of these settings, but with type extensions disabled and anonymous types enabled
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSettings.WithEncoding(System.Text.Encoding)">
            <summary>
            Change the byte-to-string encoding type
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSettings.WithDateFormats(System.String[])">
            <summary>
            Set the acceptable date formats, in descending preference order.
            Highest preference will be used for serialisation.
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSettings.WithCaseSensitivity">
            <summary>
            Add case sensitive matching to these parameters
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSettings.WithMaximumRecursionDepth(System.Int32)">
            <summary>
            Set maximum recursion depth during serialisation
            </summary>
        </member>
        <member name="M:SkinnyJson.JsonSettings.ParameterKey">
            <summary>
            Unique key for this parameter set.
            Used to key various caches.
            </summary>
        </member>
        <member name="T:SkinnyJson.SafeDictionary`2">
            <summary>
            Dictionary with thread locks
            </summary>
        </member>
        <member name="M:SkinnyJson.SafeDictionary`2.TryAdd(`0,`1)">
            <summary>
            Add a key/value pair only if the key is not already present
            </summary>
        </member>
        <member name="T:SkinnyJson.Sync">
            <summary>
            Helper class to properly wait for async tasks
            </summary>
        </member>
        <member name="M:SkinnyJson.Sync.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Run an async function synchronously and return the result
            </summary>
        </member>
        <member name="M:SkinnyJson.Sync.Run(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Run an async function synchronously
            </summary>
        </member>
        <member name="T:SkinnyJson.SyncStreamWrapper">
            <summary>
            Wrapper that tries to use either sync or async methods of a base stream.
            This prefers the synchronous methods, and falls back to a sync-runner-helper
            if not supported.
            </summary>
        </member>
        <member name="F:SkinnyJson.TypeManager.CacheSet.NamedTypeCache">
            <summary> Used to map incoming <c>"$type"</c> keys to dotnet types </summary>
        </member>
        <member name="F:SkinnyJson.TypeManager._caches">
            <summary> Per-settings caches of type info</summary>
        </member>
        <member name="F:SkinnyJson.TypeManager._reflectedTypes">
            <summary>
            Type definitions found by reflection.
            These do not need to be stored per-setting-set.
            </summary>
        </member>
        <member name="F:SkinnyJson.TypeManager._systemTextJsonSerializerOptions">
            <summary> Cached configuration for System.Text.Json methods </summary>
        </member>
        <member name="F:SkinnyJson.TypeManager._systemTextJsonWriterOptions">
            <summary> Cached configuration for System.Text.Json methods </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.FindTypeByReflection(System.String,System.String)">
            <summary>
            Try to find a type by name in any loaded assemblies
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetJsonSerializerOptions(SkinnyJson.TypePropertyInfo,System.Type)">
            <summary>
            Try to build (by reflection) a <c>JsonSerializerOptions</c> to feed to System.Text.Json methods
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetJsonWriterOptions(SkinnyJson.TypePropertyInfo,System.Type)">
            <summary>
            Try to build (by reflection) a <c>JsonWriterOptions</c> to feed to System.Text.Json methods
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.Cache(SkinnyJson.JsonSettings)">
            <summary>
            Get caches for setting spec. Creates a new set if needed.
            </summary>
        </member>
        <member name="T:SkinnyJson.TypeManager.CreateObject">
            <summary>
            Delegate for creating a new type instance
            </summary>
        </member>
        <member name="T:SkinnyJson.TypeManager.GenericGetter">
            <summary>
            Function definition to get the value of a field or properly on an object
            </summary>
            <param name="obj))">object instance to provide the value</param>
        </member>
        <member name="T:SkinnyJson.TypeManager.GenericSetter">
            <summary>
            Function definition to set the value of a field or properly on an object
            </summary>
            <param name="target">object instance to accept the value</param>
            <param name="value">value of property to set</param>
            <param name="key">optional key for dictionaries</param>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetTypeAssemblyName(System.Type,SkinnyJson.JsonSettings)">
            <summary>
            Get a shortened string name for a type's containing assembly
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.ShortenName(System.String)">
            <summary>
            Shorten an assembly qualified name
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetTypeFromCache(System.String,SkinnyJson.JsonSettings)">
            <summary>
            Try to get or build a type for a given type-name
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.FastCreateInstance(System.Type,SkinnyJson.JsonSettings)">
            <summary>
            Try to make a new instance of a type.
            Will drop down to 'SlowCreateInstance' in special cases
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetGetters(System.Type,SkinnyJson.JsonSettings)">
            <summary>
            Return a list of property/field access proxies for a type.
            This is cached after first access for each type.
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.MakeFieldGetterWithPreferredName(System.Reflection.FieldInfo,SkinnyJson.TypeManager.GenericGetter)">
            <summary>
            Build a 'getter', used for serialisation.
            This will use the first name from any name-overriding attribute,
            or the name of the member directly if not overridden.
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.MakePropertyGetterWithPreferredName(System.Reflection.PropertyInfo,SkinnyJson.TypeManager.GenericGetter)">
            <summary>
            Build a 'getter', used for serialisation.
            This will use the first name from any name-overriding attribute,
            or the name of the member directly if not overridden.
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateMyProp(System.String,System.Type,System.String,System.Collections.Generic.IEnumerable{System.Reflection.CustomAttributeData})">
            <summary>
            Read reflection data for a type
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.IsSkinnyCustomConverter(System.Type)">
            <summary>
            Return <c>true</c> if the given type is a <c>ICustomJsonConverter</c>
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.IsNullableWrapper(System.Type)">
            <summary>
            <c>true</c> if the type is <c>Nullable&lt;T&gt;</c>
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetChangeType(System.Type)">
            <summary>
            Get the true target type, excluding known wrappers
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateSetMethod(System.Reflection.PropertyInfo)">
            <summary>
            Try to create a value-setting proxy for an object property
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateGetField(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Create a value-reading proxy for an object field
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateSetField(System.Type,System.Reflection.FieldInfo)">
            <summary>
            Create a value-setting proxy for an object field
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.AnonFieldFilter(System.String)">
            <summary>
            Anonymous fields like "A" will be named like "&lt;A&gt;i__Field" in the type def; so we filter them here.
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.NormaliseCase(System.String)">
            <summary>
            Convert a string to lower case, removing a set of joining and non-printing characters
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetProperties(System.Type,System.String,SkinnyJson.JsonSettings,SkinnyJson.WarningSet)">
            <summary>
            Read the properties and public fields of a type.
            In special cases, this will also read private fields
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.CreateGetMethod(System.Reflection.PropertyInfo)">
            <summary>
            Try to create a value-reading proxy for an object property
            </summary>
        </member>
        <member name="M:SkinnyJson.TypeManager.GetAlternativeNames(System.Reflection.MemberInfo)">
            <summary>
            Returns alternative names for a field, based on various other libraries' code attributes
            </summary>
        </member>
        <member name="T:SkinnyJson.TypePropertyInfo">
            <summary>
            Record of reflected type info for fields and properties on objects
            </summary>
        </member>
        <member name="F:SkinnyJson.TypePropertyInfo.PropertyType">
            <summary>
            Type of the property or field
            </summary>
        </member>
        <member name="F:SkinnyJson.TypePropertyInfo.elementType">
            <summary>
            Array element type, or enumerable generic item type
            </summary>
        </member>
        <member name="F:SkinnyJson.TypePropertyInfo.changeType">
            <summary>
            Type of the property or field after removing known wrapper types (such as <c>Nullable&lt;T&gt;</c>)
            </summary>
        </member>
        <member name="T:SkinnyJson.WideNumber">
            <summary>
            Holds a representation of various numeric types.
            Handles casting to target types
            </summary>
        </member>
        <member name="M:SkinnyJson.WideNumber.TryParse(System.String,SkinnyJson.WideNumber@)">
            <summary>
            Try to parse a string as a range of wide number types.
            Returns true if at least one type parsed successfully.
            </summary>
        </member>
        <member name="M:SkinnyJson.WideNumber.CastTo(System.Type,System.Boolean@)">
            <summary>
            Try to cast this WideNumber type to a primitive value.
            Returns null if the cast is not supported.
            </summary>
            <param name="type">Target type</param>
            <param name="precisionLoss">Set to true if the cast is from a floating point to a fixed point or integer value; or from a fixed point to integer value</param>
            <returns></returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
    </members>
</doc>
